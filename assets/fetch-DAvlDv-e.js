import{G as we,Z as Ve,_ as Ae,r as c,$ as Ce,a0 as Oe,a1 as ke,a2 as U,a3 as a,a4 as me,a5 as re,a6 as te,a7 as ne,a8 as de,a9 as Le,aa as ee,ab as ye,ac as Fe,ad as pe,ae as ze,af as ve,ag as Me,ah as Ne,s as Ie}from"./index-DPl9zu-i.js";const be=we.use||(n=>{if(n.status==="pending")throw n;if(n.status==="fulfilled")return n.value;throw n.status==="rejected"?n.reason:(n.status="pending",n.then(f=>{n.status="fulfilled",n.value=f},f=>{n.status="rejected",n.reason=f}),n)}),ce={dedupe:!0},qe=(n,f,d)=>{const{cache:p,compare:D,suspense:l,fallbackData:m,revalidateOnMount:b,revalidateIfStale:A,refreshInterval:O,refreshWhenHidden:ae,refreshWhenOffline:M,keepPreviousData:Y}=d,[i,N,_,ie]=Ce.get(p),[e,k]=ne(n),H=c.useRef(!1),q=c.useRef(!1),T=c.useRef(e),F=c.useRef(f),Z=c.useRef(d),t=()=>Z.current,w=()=>t().isVisible()&&t().isOnline(),[o,C,X,$]=U(p,e),v=c.useRef({}).current,W=a(m)?d.fallback[e]:m,x=(s,r)=>{for(const E in v){const u=E;if(u==="data"){if(!D(s[u],r[u])&&(!a(s[u])||!D(J,r[u])))return!1}else if(r[u]!==s[u])return!1}return!0},g=c.useMemo(()=>{const s=!e||!f?!1:a(b)?t().isPaused()||l?!1:a(A)?!0:A:b,r=S=>{const L=Me(S);return delete L._k,s?{isValidating:!0,isLoading:!0,...L}:L},E=o(),u=$(),V=r(E),K=E===u?V:r(u);let h=V;return[()=>{const S=r(o());return x(S,h)?(h.data=S.data,h.isLoading=S.isLoading,h.isValidating=S.isValidating,h.error=S.error,h):(h=S,S)},()=>K]},[p,e]),I=me.useSyncExternalStore(c.useCallback(s=>X(e,(r,E)=>{x(E,r)||s()}),[p,e]),g[0],g[1]),G=!H.current,oe=i[e]&&i[e].length>0,z=I.data,R=a(z)?W:z,j=I.error,B=c.useRef(R),J=Y?a(z)?B.current:z:R,se=oe&&!a(j)?!1:G&&!a(b)?b:t().isPaused()?!1:l?a(R)?!1:A:a(R)||A,ge=!!(e&&f&&G&&se),Pe=a(I.isValidating)?ge:I.isValidating,De=a(I.isLoading)?ge:I.isLoading,Q=c.useCallback(async s=>{const r=F.current;if(!e||!r||q.current||t().isPaused())return!1;let E,u,V=!0;const K=s||{},h=!_[e]||!K.dedupe,S=()=>ve?!q.current&&e===T.current&&H.current:e===T.current,L={isValidating:!1,isLoading:!1},Re=()=>{C(L)},Ee=()=>{const P=_[e];P&&P[1]===u&&delete _[e]},Se={isValidating:!0};a(o().data)&&(Se.isLoading=!0);try{if(h&&(C(Se),d.loadingTimeout&&a(o().data)&&setTimeout(()=>{V&&S()&&t().onLoadingSlow(e,d)},d.loadingTimeout),_[e]=[r(k),Le()]),[E,u]=_[e],E=await E,h&&setTimeout(Ee,d.dedupingInterval),!_[e]||_[e][1]!==u)return h&&S()&&t().onDiscarded(e),!1;L.error=te;const P=N[e];if(!a(P)&&(u<=P[0]||u<=P[1]||P[1]===0))return Re(),h&&S()&&t().onDiscarded(e),!1;const y=o().data;L.data=D(y,E)?y:E,h&&S()&&t().onSuccess(E,e,d)}catch(P){Ee();const y=t(),{shouldRetryOnError:ue}=y;y.isPaused()||(L.error=P,h&&S()&&(y.onError(P,e,y),(ue===!0||de(ue)&&ue(P))&&(!t().revalidateOnFocus||!t().revalidateOnReconnect||w())&&y.onErrorRetry(P,e,y,Te=>{const le=i[e];le&&le[0]&&le[0](ee.ERROR_REVALIDATE_EVENT,Te)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return V=!1,Re(),!0},[e,p]),he=c.useCallback((...s)=>ye(p,T.current,...s),[]);if(re(()=>{F.current=f,Z.current=d,a(z)||(B.current=z)}),re(()=>{if(!e)return;const s=Q.bind(te,ce);let r=0;const u=Fe(e,i,(V,K={})=>{if(V==ee.FOCUS_EVENT){const h=Date.now();t().revalidateOnFocus&&h>r&&w()&&(r=h+t().focusThrottleInterval,s())}else if(V==ee.RECONNECT_EVENT)t().revalidateOnReconnect&&w()&&s();else{if(V==ee.MUTATE_EVENT)return Q();if(V==ee.ERROR_REVALIDATE_EVENT)return Q(K)}});return q.current=!1,T.current=e,H.current=!0,C({_k:k}),se&&(a(R)||pe?s():ze(s)),()=>{q.current=!0,u()}},[e]),re(()=>{let s;function r(){const u=de(O)?O(o().data):O;u&&s!==-1&&(s=setTimeout(E,u))}function E(){!o().error&&(ae||t().isVisible())&&(M||t().isOnline())?Q(ce).then(r):r()}return r(),()=>{s&&(clearTimeout(s),s=-1)}},[O,ae,M,e]),c.useDebugValue(J),l&&a(R)&&e){if(!ve&&pe)throw new Error("Fallback data is required when using suspense in SSR.");F.current=f,Z.current=d,q.current=!1;const s=ie[e];if(!a(s)){const r=he(s);be(r)}if(a(j)){const r=Q(ce);a(J)||(r.status="fulfilled",r.value=!0),be(r)}else throw j}return{mutate:he,get data(){return v.data=!0,J},get error(){return v.error=!0,j},get isValidating(){return v.isValidating=!0,Pe},get isLoading(){return v.isLoading=!0,De}}},We=Ae(qe),xe=n=>ne(n?n(0,null):null)[0],fe=Promise.resolve(),Ue=n=>(f,d,p)=>{const D=c.useRef(!1),{cache:l,initialSize:m=1,revalidateAll:b=!1,persistSize:A=!1,revalidateFirstPage:O=!0,revalidateOnMount:ae=!1,parallel:M=!1}=p,[,,,Y]=Ce.get(Oe);let i;try{i=xe(f),i&&(i=ke+i)}catch{}const[N,_,ie]=U(l,i),e=c.useCallback(()=>a(N()._l)?m:N()._l,[l,i,m]);me.useSyncExternalStore(c.useCallback(t=>i?ie(i,()=>{t()}):()=>{},[l,i]),e,e);const k=c.useCallback(()=>{const t=N()._l;return a(t)?m:t},[i,m]),H=c.useRef(k());re(()=>{if(!D.current){D.current=!0;return}i&&_({_l:A?H.current:k()})},[i,l]);const q=ae&&!D.current,T=n(i,async t=>{const w=N()._i,o=N()._r;_({_r:te});const C=[],X=k(),[$]=U(l,t),v=$().data,W=[];let x=null;for(let g=0;g<X;++g){const[I,G]=ne(f(g,M?null:x));if(!I)break;const[oe,z]=U(l,I);let R=oe().data;const j=b||w||a(R)||O&&!g&&!a(v)||q||v&&!a(v[g])&&!p.compare(v[g],R);if(d&&(typeof o=="function"?o(R,G):j)){const B=async()=>{if(!(I in Y))R=await d(G);else{const se=Y[I];delete Y[I],R=await se}z({data:R,_k:G}),C[g]=R};M?W.push(B):await B()}else C[g]=R;M||(x=R)}return M&&await Promise.all(W.map(g=>g())),_({_i:te}),C},p),F=c.useCallback(function(t,w){const o=typeof w=="boolean"?{revalidate:w}:w||{},C=o.revalidate!==!1;return i?(C&&(a(t)?_({_i:!0,_r:o.revalidate}):_({_i:!1,_r:o.revalidate})),arguments.length?T.mutate(t,{...o,revalidate:C}):T.mutate()):fe},[i,l]),Z=c.useCallback(t=>{if(!i)return fe;const[,w]=U(l,i);let o;if(de(t)?o=t(k()):typeof t=="number"&&(o=t),typeof o!="number")return fe;w({_l:o}),H.current=o;const C=[],[X]=U(l,i);let $=null;for(let v=0;v<o;++v){const[W]=ne(f(v,$)),[x]=U(l,W),g=W?x().data:te;if(a(g))return F(X().data);C.push(g),$=g}return F(C)},[i,l,F,k]);return{size:k(),setSize:Z,mutate:F,get data(){return T.data},get error(){return T.error},get isValidating(){return T.isValidating},get isLoading(){return T.isLoading}}},He=Ve(We,Ue),_e=10,Ge=n=>{const{data:f,mutate:d,error:p}=Ne("api/supabase/profile",async()=>{const{data:D,error:l}=await Ie.from("Profiles").select().eq("id",n).single();if(l)throw l.message;return D});return{data:f,mutate:d,error:p}},je=()=>{const n=async m=>{console.log(m);const b=parseInt(m.split("=")[2],10);console.log(`Fetching page ${b}`);const{data:A,error:O}=await Ie.from("Posts").select(`
        *,
        user: Profiles (username)
      `).order("created_at",{ascending:!1}).range(b*_e,(b+1)*_e-1);if(O)throw O.message;return console.log(A),A},f=(m,b)=>b&&!b.length?null:`posts?is_published=true&page=${m}`,{data:d,size:p,setSize:D,error:l}=He(f,n,{revalidateOnFocus:!1,revalidateOnReconnect:!1});return{data:d,size:p,setSize:D,error:l}};export{Ge as a,je as u};
